(1) 템플릿 메소드 패턴 - 슈퍼클래스에 기본적인 로직의 흐름(ex. 커넥션 가져오기, SQL 생성, 실행, 반환)을 만들고,
그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법


-> UserDao에서 getConnection() 을 추상 메소드로 선언한 뒤 UserDao를 상속한 NUserDao, DUserDao에서 getConnection()을 재정의하고 사용한 기법
------------------------------------------------
변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 함.
슈퍼클래스에서는 미리 추상 메소드 또는 오버라이딩 가능한 메소드를 정의해두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만든다.
슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 훅(hook) 메소드라고 한다.
서브클래스에서는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장한다.

public abstract class Super {
	public void templateMethod() {
		// 기본 알고리즘 코드
		hookMethod();
		abstractMethod();
		...
	}

	protected void hookMethod() { }	 // 선택적으로 오버라이드 가능한 훅 메소드
	public abstract void abstractMethod(); // 서브클래스에서 반드시 구현해야 하는 추상 메소드
	
}

public class Sub1 extends Super {
	protected void hookMethod() {
		...
	}

	public void abstractMethod() {
		...
	}
}

(2) 팩토리 메소드 패턴 - 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것

-> 서브 클래스인 NUserDao, DUserDao에서 Connection 타입 오브젝트를 생성할 방법을 결정하고있으므로 이것도 하나의 팩토리 메소드 패턴이라 볼 수 있음.

---------------------------------------

팩토리 메소드 패턴도 템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴이다. 그래서 구조도 비슷함.
슈퍼클래스 코드에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다. 이 메소드는 주로
인터페이스 타입으로 오브젝트를 리턴하므로 서브클래스에서 정확히 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스에서는
알지 못한다. 사실 관심도 없다. 이렇게 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를
팩토리 메소드라고 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법을
팩토리 메소드 패턴이라고 한다.

-----------------------------------------------
(3) 개방 폐쇄 원칙, OCP, Open Closed Principle

클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀있어야 한다.

UserDao는 DB 연결 방법이라는 기능을 확장하는 데에 열려있다. UserDao에 전혀 영향을 주지 않고도
얼마든지 기능을 확장할 수 있게 되어 있음.
동시에 UserDao는 자신의 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지 않고 유지할 수 있으므로
변경에는 닫혀있다.

--------------------------------------------------------------------------
(4) 전략 패턴

자신의 기능 맥락(context)에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로
외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게하는
디자인 패턴, 여기서 UserDao는 전략패턴의 컨텍스트이고 컨텍스트는 자신의 기능을 수행하는데 필요한
기능 중에서 변경 가능한, DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고
이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리되어 있다. 전략은 컨텍스트의 생성자 등을
통해 제공해주는게 일반적이다.

---------------------------------------------

(5) 템플릿/콜백 패턴
전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식

@@@@리팩토링@@@@
가장 먼저, 중복되는 코드를 분리할 방법을 생각해봄
중복된 코드는 먼저 메소드로 분리를 시도.
그 중 일부 작업을 필요에 따라 바꾸어 사용해야 한다면 인터페이스를 사이에 두고 분리해서 전략 패턴을
적용하고 DI로 의존관계를 관리하도록 만듬
그런데 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류가 만들어질 수 있다면 템플릿/콜백 패턴을
적용해보는것도 고려

































 